/* eslint  max-statements: [2, 40] */
/* eslint  complexity: [2, 40] */
"use strict";


var assert = require("assert");

function renew_certificate(certificate, new_startDate, new_endDate, callback) {

    assert(new_endDate instanceof Date);
    assert(new_endDate instanceof Date);
    var options ={};
    async.series([
        displaySubtitle.bind(null, "renew ertificate"),
        execute_openssl.bind(null, "ca " + configOption +
            " -policy policy_anything " +
            " -out newcert.pem " +
            " -infiles newreq.pem " +
            " -startdate  " + x509Date(new_startDate) +
            " -enddate " + x509Date(new_endDate) ,options)
    ], callback);

}


/**
 *
 * @param options
 * @param options.commonName       {String}
 * @param options.organization     {String}
 * @param options.organizationUnit {String}
 * @param options.locality         {String}
 * @param options.state            {String}
 * @param options.country          {String}
 *
 * @param options.applicationUri   {String}
 * @param options.domainNames      {Array<String>}
 * @param options.ipAddresses      {Array<String>}
 * @param options.keySize          {Number}
 *
 * @param options.startDate        {Date}= today
 * @param options.validity         {Number} number of days for validation [15*360 =15 years]
 * @param options.selfSigned       {Boolean}
 *
 * @param options.prefix           {String} "new_certificate";
 *
 * @param options.privateKey       {String} the privateKey filename or null, if private key need to be generated
 * @param callback {Function}
 */
function createNewCertificate(options, callback) {

    assert(_.isFunction(callback));

    var tasks = [
        construct_CertificateAuthority.bind(this)
    ];


    var base_name = config.certificateDir;
    assert(fs.existsSync(base_name));

    // -----------------------------------------------------------------------------
    // Subject
    // -----------------------------------------------------------------------------
    options.commonName = options.commonName || config.commonName;
    options.organization = options.organization || config.organization;
    options.organizationUnit = options.organizationUnit || config.organizationUnit;
    options.locality = options.locality || config.locality;
    options.state = options.state || config.state;
    options.country = options.country || config.country;
    assert(options.country.length === 2);

    // -----------------------------------------------------------------------------
    // OPCUA Information
    // -----------------------------------------------------------------------------
    options.applicationUri = options.applicationUri || makeApplicationUrn(hostname, "NodeOPCUA-Client");
    options.domainNames = [
        "localhost"
    ];
    options.ipAddresses = options.ipAddresses || [];

    // -----------------------------------------------------------------------------
    // Certificate settings
    // -----------------------------------------------------------------------------
    options.keySize = options.keySize || config.keySize; // bits
    assert(options.keySize === 1024 || options.keySize === 2048 || options.keySize === 4096);
    options.validity = options.validity || config.validity;

    options.selfSigned = !!(options.selfSigned);
    options.startDate = options.startDate || today;

    assert(options.startDate instanceof Date);
    assert(_.isNumber(options.validity));


    var private_key;

    if (options.privateKey) {
        options.privateKey = make_path(process.cwd(), options.privateKey);
        if (!fs.existsSync(options.privateKey)) {
            throw new Error("Cannot find private key ", options.privateKey);
        }
        private_key = options.privateKey;
        console.log("          reusing private key : ", private_key);

    } else {
        options.prefix = options.prefix || "new_certificate_XX";
        private_key = toolbox.make_path(base_name, options.prefix + "_private_key.pem");
        tasks.push(toolbox.createPrivateKey.bind(null, private_key, options.keySize));
    }

    var certificate = toolbox.make_path(base_name, options.prefix + "_certificate.pem");

    //xx getPublicKeyFromPrivateKey.bind(null, private_key, public_key),
    tasks = tasks.concat([

        _createCertificate.bind(null, options.selfSigned, certificate, private_key, options.applicationUri, options.startDate, options.validity),

        displayTitle.bind(null, " Result"),

        function (callback) {

            console.log("  private key : ", private_key.cyan);
            //xx console.log("  public  key : ", public_key.cyan);
            console.log("  certificate : ", certificate.cyan);
            callback();
        }
    ]);
    async.series(tasks, callback);
}





function createCertificateFromCommandLine(argv, callback) {


    //example : node bin\crypto_create_CA.js --new --selfSigned --applicationUri urn:localhost:MyProduct --prefix aa --force
    //example : node bin\crypto_create_CA.js --new --privateKey my_private_key.pem --applicationUri urn:localhost:MyProduct --prefix aa --force

    assert(_.isString(argv.applicationUri), "--new require applicationUri to be specified");
    assert(_.isString(argv.prefix), "--new requires a prefix to be specified");

    // urn:COMPUTERNAME:PRODUCT
    assert(argv.applicationUri.length < 64, "applicationUri cannot exceed 64 characters");
    var options = {
        applicationUri: argv.applicationUri
    };

    options.prefix = argv.prefix;
    options.privateKey = argv.privateKey;
    options.selfSigned = argv.selfSigned;

    createNewCertificate(options, function (err) {
        console.log("Done ...");
        callback(err);
    });
}
